<?php

namespace Respectify;

use React\Http\Browser;
use React\EventLoop\Loop;
use React\Promise\PromiseInterface;
use Psr\Http\Message\ResponseInterface;
use Respectify\Exceptions\BadRequestException;
use Respectify\Exceptions\UnauthorizedException;
use Respectify\Exceptions\UnsupportedMediaTypeException;
use Respectify\Exceptions\JsonDecodingException;
use Respectify\Exceptions\RespectifyException;

// Import auto-generated schema classes (generated from Python schemas.py)
use Respectify\Schemas\LogicalFallacy;
use Respectify\Schemas\ObjectionablePhrase;
use Respectify\Schemas\NegativeTonePhrase;
use Respectify\Schemas\CommentScore;
use Respectify\Schemas\SpamDetectionResult;
use Respectify\Schemas\OnTopicResult;
use Respectify\Schemas\BannedTopicsResult;
use Respectify\Schemas\CommentRelevanceResult;
use Respectify\Schemas\DogwhistleDetection;
use Respectify\Schemas\DogwhistleDetails;
use Respectify\Schemas\DogwhistleResult;
use Respectify\Schemas\MegaCallResult;
use Respectify\Schemas\InitTopicResponse;

// INLINE SCHEMA CLASSES REMOVED - NOW USING AUTO-GENERATED ONES FROM src/Schemas/
// These are generated by running: python schema_generator.py
// DO NOT add schema classes here - they are auto-generated from Python schemas.py


/**
 * RespectifyClientAsync lets you interact with the Respectify API. It is asynchronous, meaning
 * you need to run the event loop to get results. This is important for high-performance applications.
 * This uses [ReactPHP](https://reactphp.org/) under the hood, and you must call the `run()` method
 * to [run the event loop](https://reactphp.org/event-loop/) (if it's not already running) *after* you call the API methods
 * in order to resolve the promises that this API returns.
 * 
 * See the [Quick Start](/docs/SampleCode) for sample code.
 */
class RespectifyClientAsync {
    private const DEFAULT_BASE_URL = 'https://app.respectify.org';
    private const DEFAULT_VERSION = 0.2;

    private Browser $client;
    private $loop;
    private string $email;
    private string $apiKey;
    private string $baseUrl;
    private string $version;
    private ?string $website;

    /**
     * Create an instance of the async Respectify API client.
     * @param string $email An email address.
     * @param string $apiKey A hex string representing the API key.
     * @param string|null $baseUrl Optional. The base URL for the Respectify API. If not provided, uses the default.
     * @param float|null $version Optional. The API version. If not provided, uses the default.
     * @param string|null $website Optional. The website domain for license tracking.
     * @return self
     */
    public function __construct(
        string $email, 
        string $apiKey, 
        ?string $baseUrl = null, 
        ?float $version = null,
        ?string $website = null
    ) {
        $this->loop = Loop::get();
        $this->client = new Browser($this->loop);
        $this->email = $email;
        $this->apiKey = $apiKey;
        $this->baseUrl = rtrim($baseUrl ?? self::DEFAULT_BASE_URL, '/');
        $formatted_api_version = sprintf('%.1f', floatval($version ?? self::DEFAULT_VERSION)); // Always 1DP, eg, 1.0 or 0.2
        $this->version = $formatted_api_version;
        $this->website = $website;
    }

    /**
     * Get the headers for the API request.
     * @return array<string, string> An associative array mapping HTTP request header names to header values.
    */
    private function getHeaders(): array {
        $headers = [
            'X-User-Email' => $this->email,
            'X-API-Key' => $this->apiKey,
            'Content-Type' => 'application/json'
        ];
        
        if ($this->website !== null) {
            $headers['X-Website'] = $this->website;
        }
        
        return $headers;
    }

    /**
     * Get the full API URL for a given endpoint.
     * @param string $endpoint The API endpoint path.
     * @return string The complete API URL.
     */
    private function getApiUrl(string $endpoint): string {
        return "{$this->baseUrl}/v{$this->version}/{$endpoint}";
    }

    /**
     * Handle errors from the API response. This always raises an exception. Ideally, $response is a ResponseInterface
     * but handle anything.
     * @param mixed $response
     * @throws BadRequestException
     * @throws UnauthorizedException
     * @throws UnsupportedMediaTypeException
     * @throws RespectifyException
     */
    private function handleError(mixed $response): void {
        if ($response === null) {
            throw new RespectifyException('Unknown error occurred: response is null');
        }
        if (!$response instanceof ResponseInterface) {
            if ($response instanceof \Exception) {
                throw new RespectifyException('Generic error: ' . $response->getMessage(), $response->getCode(), $response);
            }
            throw new RespectifyException('Unknown error occurred');
        }
        switch ($response->getStatusCode()) {
            case 400:
                throw new BadRequestException('Bad Request: ' . htmlspecialchars($response->getReasonPhrase(), ENT_QUOTES, 'UTF-8'));
            case 401:
                throw new UnauthorizedException('Unauthorized: ' . htmlspecialchars($response->getReasonPhrase(), ENT_QUOTES, 'UTF-8'));
            case 415:
                throw new UnsupportedMediaTypeException('Unsupported Media Type: ' . htmlspecialchars($response->getReasonPhrase(), ENT_QUOTES, 'UTF-8'));
            default:
                throw new RespectifyException('Error: ' . htmlspecialchars((string)$response->getStatusCode(), ENT_QUOTES, 'UTF-8') . ' - ' . htmlspecialchars($response->getReasonPhrase(), ENT_QUOTES, 'UTF-8'));
        }
    }

    /**
     * Initialize a Respectify topic with the given data. This internal method is used by the public methods.
     *
     * @param array $data The data to initialize the topic.
     * @return PromiseInterface<string> A [promise](https://reactphp.org/promise/#promiseinterface) that resolves to the article ID. This is a string containing a UUID. You must keep this (eg, store it in a database) to use in future when evaluating comments written about this topic.
     * @throws JsonDecodingException
     * @throws RespectifyException
     */
    private function initTopic(array $data): PromiseInterface {
        return $this->client->post(
            $this->getApiUrl('inittopic'),
            $this->getHeaders(),
            json_encode($data)
        )->then(function (ResponseInterface $response) {
            if ($response->getStatusCode() === 200) {
                try {
                    $responseData = json_decode((string)$response->getBody(), true);
                    if (isset($responseData['article_id'])) {
                        return $responseData['article_id'];
                    } else {
                        throw new JsonDecodingException('Error: article_id not found in the JSON response: ' . htmlspecialchars($response->getBody(), ENT_QUOTES, 'UTF-8'));
                    }
                } catch (\Exception $e) {
                    throw new JsonDecodingException('Error decoding JSON response: ' . htmlspecialchars($e->getMessage(), ENT_QUOTES, 'UTF-8') . ' from response: ' . htmlspecialchars($response->getBody(), ENT_QUOTES, 'UTF-8'));
                }
            } else {
                $this->handleError($response);
            }
        })->otherwise(function (\Exception $e) {
            if ($e instanceof \React\Http\Message\ResponseException) {
                $response = $e->getResponse();
                $this->handleError($response);
            } else {
                throw $e;
            }
        });
    }

    /**
     * Initialize a Respectify topic, using plain text or Markdown.
     *
     * @param string $text The text content to initialize the topic.
     * @param string|null $topicDescription Optional description of the topic to provide additional context.
     * @return PromiseInterface<string> A [promise](https://reactphp.org/promise/#promiseinterface) that resolves to the article ID. This is a string containing a UUID. You must keep this (eg, store it in a database) to use in future when evaluating comments written about this topic.
     * @throws BadRequestException
     * @throws RespectifyException
     */
    public function initTopicFromText(string $text, ?string $topicDescription = null): PromiseInterface {
        if (empty($text)) {
            throw new BadRequestException('Text must be provided'); // Server will reply with a 400 Bad Request anyway, this is faster
        }
        $data = ['text' => $text];
        if ($topicDescription !== null && !empty($topicDescription)) {
            $data['topic_description'] = $topicDescription;
        }
        return $this->initTopic($data);
    }

    /**
     * Initialize a Respectify topic with the contents of a URL.
     * The URL must be publicly accessible.
     * It can point to any text, Markdown, HTML, or PDF file.
     *  * Check [the REST API documentation](/api/initialize-topic) for a full list of the supported media types.
     *
     * @param string $url The URL pointing to the content to initialize the topic.
     * @param string|null $topicDescription Optional description of the topic to provide additional context.
     * @return PromiseInterface<string> A [promise](https://reactphp.org/promise/#promiseinterface) that resolves to the article ID as a UUID string.
     * @throws BadRequestException
     * @throws RespectifyException
     */
    public function initTopicFromUrl(string $url, ?string $topicDescription = null): PromiseInterface {
        if (empty($url)) {
            throw new BadRequestException('URL must be provided'); // Server will reply with a 400 Bad Request anyway, this is faster
        }
        $data = ['url' => $url];
        if ($topicDescription !== null && !empty($topicDescription)) {
            $data['topic_description'] = $topicDescription;
        }
        return $this->initTopic($data);
    }

    /**
     * Sanitise the data returned from the server.
     * @param $data The data to sanitise; an array of strings or arrays (coming from JSON)
     * @return string The sanitised data, in the same structure as the input
     */
    private function sanitiseReturnedData($data) {
        if (is_string($data)) {
            // Trim whitespace
            $data = trim($data);
            // Remove control characters
            $data = preg_replace('/[\x00-\x1F\x7F]/u', '', $data);
            // Strip slashes already added (so not double-slashed)
            // and convert special characters to HTML entities
            return htmlspecialchars(stripslashes($data), ENT_QUOTES, 'UTF-8');
        } elseif (is_array($data)) {
            return array_map([$this, 'sanitiseReturnedData'], $data);
        }
        return $data;
    }

    /**
     * Evaluate a comment in the context of the article/blog/etc the conversation is about, and optionally the comment it is replying to.
     *
     * This is Respectify's main API and the one you will likely call the most. It returns
     * a [promise](https://reactphp.org/promise/#promiseinterface) to a [`CommentScore`](CommentScore) object which has a
     * wide variety of information and assessments.
     * 
     * See the [Quick Start](/docs/PHP/SampleCode) for code samples showing how to use this.
     *
     * @param string $articleContextId a string containing UUID that identifies the article/blog/etc that this comment was written in the context of. This is the value you get by calling `initTopicFromText` or `initTopicFromUrl`.
     * @param string $comment The comment text: this is what is evaluated.
     * @param string|null $replyToComment Provides additional context: the comment to which the one being evaluated is a reply. This is optional.
     * @return PromiseInterface<CommentScore> A [promise](https://reactphp.org/promise/#promiseinterface) that resolves to a [CommentScore](CommentScore) object.
     * @throws RespectifyException
     * @throws JsonDecodingException
     */
    public function evaluateComment(string $articleContextId, string $comment, ?string $replyToComment = null): PromiseInterface {
        $data = [
            'article_context_id' => $articleContextId,
            'comment' => $comment,
        ];
    
        if ($replyToComment !== null) {
            $data['reply_to_comment'] = $replyToComment;
        }
    
        return $this->client->post(
            $this->getApiUrl('commentscore'),
            $this->getHeaders(),
            json_encode($data)
        )->then(function (ResponseInterface $response) {
            if ($response->getStatusCode() === 200) {
                try {
                    $responseData = json_decode((string)$response->getBody(), true);

                    // Sanitise the data. It was sanitised when sent to the API, but the return results will include
                    // parts of what the user wrote, so need to be sanitised.
                    // For every key in the returned JSON, sanitise the value. The value can be a string or an array that mimics
                    // the structure of the input.
                    
                    // Sanitize the entire response data
                    $responseData = $this->sanitiseReturnedData($responseData);

                    return new CommentScore($responseData);
                } catch (\Exception $e) {
                    throw new JsonDecodingException('Error decoding JSON response: ' . htmlspecialchars($e->getMessage(), ENT_QUOTES, 'UTF-8') . ' from response: ' . htmlspecialchars($response->getBody(), ENT_QUOTES, 'UTF-8'));
                }
            } else {
                $this->handleError($response);
            }
        })->otherwise(function (\Exception $e) {
            if ($e instanceof \React\Http\Message\ResponseException) {
                $response = $e->getResponse();
                $this->handleError($response);
            } else {
                throw $e;
            }
        });
    }

    /**
     * Check user credentials and return account status information if there is any issue with the account.
     * This can only return info about the account whose correct credentials were provided when creating the RespectifyClientAsync instance.
     *
     * @return PromiseInterface<array> A promise that resolves to an array containing a boolean success flag and a string with account status information.
     * @throws RespectifyException
     * @throws JsonDecodingException
     */
    public function checkUserCredentials(): PromiseInterface {
        return $this->client->get(
            $this->getApiUrl('usercheck'),
            $this->getHeaders()
        )->then(function (ResponseInterface $response) {
            // Only if got 200 OK - anything else should be a promise rejection for the 
            // otherwise function
            if ($response->getStatusCode() !== 200) {
                $this->handleError($response);
            }
            try {
                $responseData = json_decode((string)$response->getBody(), true);
                if (isset($responseData['success'])) {
                    $success = filter_var($responseData['success'], FILTER_VALIDATE_BOOLEAN); // Convert string, eg "true", to bool
                    return [$success, $responseData['info']];
                } else {
                    throw new JsonDecodingException('Unexpected response structure from response: ' . htmlspecialchars($response->getBody(), ENT_QUOTES, 'UTF-8'));
                }
            } catch (\Exception $e) {
                throw new JsonDecodingException('Error decoding JSON response: ' . htmlspecialchars($e->getMessage(), ENT_QUOTES, 'UTF-8') . ' from response: ' . htmlspecialchars($response->getBody(), ENT_QUOTES, 'UTF-8'));
            }
        })->otherwise(function (\Exception $e) {
            if ($e instanceof \React\Socket\ConnectException) {
                throw new RespectifyException('Service not found: ' . $e->getMessage(), $e->getCode(), $e);
            }
            if ($e instanceof \React\Http\Message\ResponseException) {
                $response = $e->getResponse();
                if ($response !== null && $response->getStatusCode() === 401) {
                    return [false, 'Unauthorized. This means there was an error with the email and/or API key. Please check them and try again.'];
                } elseif ($response instanceof ResponseInterface) {
                    throw new RespectifyException(
                        'HTTP error: ' . htmlspecialchars((string)$response->getStatusCode(), ENT_QUOTES, 'UTF-8') . ' ' . htmlspecialchars($response->getReasonPhrase(), ENT_QUOTES, 'UTF-8')
                    );
                } else {
                    throw new RespectifyException('HTTP error: Response is missing');
                }
            }
            // Fallback: rethrow or wrap the original error for better debugging.
            throw new RespectifyException('Error: ' . get_class($e) . ": " . $e->getMessage(), $e->getCode(), $e);
        });
    }

    /**
     * Checks if a comment is spam.
     *
     * This endpoint allows you to evaluate a comment for spam without the full comment score analysis.
     * The article context is optional, and if omitted the comment is evaluated on its own.
     * 
     * @param string $comment The comment text to check for spam.
     * @param string|null $articleContextId Optional. The article context UUID from initTopicFromText/initTopicFromUrl.
     * @return PromiseInterface<SpamDetectionResult> A promise that resolves to a SpamDetectionResult object.
     * @throws BadRequestException
     * @throws RespectifyException
     */
    public function checkSpam(string $comment, ?string $articleContextId = null): PromiseInterface {
        if (empty($comment)) {
            throw new BadRequestException('Comment must be provided');
        }

        $data = [
            'comment' => $comment
        ];

        if ($articleContextId !== null) {
            $data['article_context_id'] = $articleContextId;
        }

        return $this->client->post(
            $this->getApiUrl('antispam'),
            $this->getHeaders(),
            json_encode($data)
        )->then(function (ResponseInterface $response) {
            if ($response->getStatusCode() === 200) {
                try {
                    $responseData = json_decode((string)$response->getBody(), true);
                    
                    // Sanitize the response data
                    $responseData = $this->sanitiseReturnedData($responseData);
                    
                    return new SpamDetectionResult($responseData);
                } catch (\Exception $e) {
                    throw new JsonDecodingException('Error decoding JSON response: ' . htmlspecialchars($e->getMessage(), ENT_QUOTES, 'UTF-8') . ' from response: ' . htmlspecialchars($response->getBody(), ENT_QUOTES, 'UTF-8'));
                }
            } else {
                $this->handleError($response);
            }
        })->otherwise(function (\Exception $e) {
            if ($e instanceof \React\Http\Message\ResponseException) {
                $response = $e->getResponse();
                $this->handleError($response);
            } else {
                throw $e;
            }
        });
    }

    /**
     * Evaluates the relevance of a comment to the article it's a comment on.
     *
     * This endpoint also checks for topics the site admin does not want discussed.
     * It helps keep conversations relevant or on-topic and allows site admins to disallow
     * conversation on specific topics.
     * 
     * @param string $articleContextId The article context UUID from initTopicFromText/initTopicFromUrl.
     * @param string $comment The comment text to evaluate for relevance.
     * @param array|null $bannedTopics Optional. List of banned topics to check against.
     * @return PromiseInterface<CommentRelevanceResult> A promise that resolves to a CommentRelevanceResult object.
     * @throws BadRequestException
     * @throws RespectifyException
     */
    public function checkRelevance(string $articleContextId, string $comment, ?array $bannedTopics = null): PromiseInterface {
        if (empty($articleContextId)) {
            throw new BadRequestException('Article context ID must be provided');
        }
        
        if (empty($comment)) {
            throw new BadRequestException('Comment must be provided');
        }

        $data = [
            'article_context_id' => $articleContextId,
            'comment' => $comment
        ];

        if ($bannedTopics !== null && !empty($bannedTopics)) {
            $data['banned_topics'] = $bannedTopics;
        }

        return $this->client->post(
            $this->getApiUrl('commentrelevance'),
            $this->getHeaders(),
            json_encode($data)
        )->then(function (ResponseInterface $response) {
            if ($response->getStatusCode() === 200) {
                try {
                    $responseData = json_decode((string)$response->getBody(), true);
                    
                    // Sanitize the response data
                    $responseData = $this->sanitiseReturnedData($responseData);
                    
                    return new CommentRelevanceResult($responseData);
                } catch (\Exception $e) {
                    throw new JsonDecodingException('Error decoding JSON response: ' . htmlspecialchars($e->getMessage(), ENT_QUOTES, 'UTF-8') . ' from response: ' . htmlspecialchars($response->getBody(), ENT_QUOTES, 'UTF-8'));
                }
            } else {
                $this->handleError($response);
            }
        })->otherwise(function (\Exception $e) {
            if ($e instanceof \React\Http\Message\ResponseException) {
                $response = $e->getResponse();
                $this->handleError($response);
            } else {
                throw $e;
            }
        });
    }

    /**
     * Analyzes a comment for dogwhistle content - coded language that appears reasonable but contains hidden meanings.
     *
     * @param string $articleContextId The article context UUID from initTopicFromText/initTopicFromUrl
     * @param string $comment The comment text to analyze for dogwhistles
     * @param array|null $sensitiveTopics Optional. List of sensitive topics to watch for
     * @param array|null $dogwhistleExamples Optional. List of dogwhistle examples to look for
     * @return PromiseInterface<DogwhistleResult> A promise that resolves to a DogwhistleResult object
     * @throws BadRequestException If the request parameters are invalid
     * @throws UnauthorizedException If the API credentials are invalid
     * @throws UnsupportedMediaTypeException If the content type is not supported
     * @throws JsonDecodingException If the JSON response cannot be decoded
     * @throws RespectifyException For other API errors
     */
    public function checkDogwhistle(string $articleContextId, string $comment, ?array $sensitiveTopics = null, ?array $dogwhistleExamples = null): PromiseInterface {
        $data = [
            'article_context_id' => $articleContextId,
            'comment' => $comment
        ];

        if ($sensitiveTopics !== null && !empty($sensitiveTopics)) {
            $data['sensitive_topics'] = $sensitiveTopics;
        }

        if ($dogwhistleExamples !== null && !empty($dogwhistleExamples)) {
            $data['dogwhistle_examples'] = $dogwhistleExamples;
        }

        return $this->client->post(
            $this->getApiUrl('dogwhistle'),
            $this->getHeaders(),
            json_encode($data)
        )->then(function (ResponseInterface $response) {
            if ($response->getStatusCode() === 200) {
                try {
                    $responseData = json_decode((string)$response->getBody(), true);
                    
                    // Sanitize the response data
                    $responseData = $this->sanitiseReturnedData($responseData);
                    
                    return new DogwhistleResult($responseData);
                } catch (\Exception $e) {
                    throw new JsonDecodingException('Error decoding JSON response: ' . htmlspecialchars($e->getMessage(), ENT_QUOTES, 'UTF-8') . ' from response: ' . htmlspecialchars($response->getBody(), ENT_QUOTES, 'UTF-8'));
                }
            } else {
                $this->handleError($response);
            }
        })->otherwise(function (\Exception $e) {
            if ($e instanceof \React\Http\Message\ResponseException) {
                $response = $e->getResponse();
                $this->handleError($response);
            } else {
                throw $e;
            }
        });
    }

    /**
     * Performs a "mega call" to evaluate a comment using multiple Respectify services in a single API call.
     * This method allows you to run any combination of services in one API call.
     *
     * @param string $comment The comment text to evaluate
     * @param string|null $articleContextId Optional. The article context UUID from initTopicFromText/initTopicFromUrl. Required for relevance, commentScore, and dogwhistle checks.
     * @param array $services List of services to include in the call. Valid values: 'spam', 'relevance', 'commentscore', 'dogwhistle'
     * @param array|null $bannedTopics Optional. List of banned topics to check against when 'relevance' is included
     * @param string|null $replyToComment Optional. The comment to which the evaluated comment is replying, used when 'commentscore' is included
     * @param array|null $sensitiveTopics Optional. List of sensitive topics to watch for when 'dogwhistle' is included
     * @param array|null $dogwhistleExamples Optional. List of dogwhistle examples to look for when 'dogwhistle' is included
     * @return PromiseInterface<MegaCallResult> A promise that resolves to a MegaCallResult object containing the requested evaluations
     * @throws BadRequestException
     * @throws RespectifyException
     */
    public function megacall(
        string $comment,
        ?string $articleContextId = null,
        array $services = ['spam', 'relevance', 'commentscore'],
        ?array $bannedTopics = null,
        ?string $replyToComment = null,
        ?array $sensitiveTopics = null,
        ?array $dogwhistleExamples = null
    ): PromiseInterface {
        if (empty($comment)) {
            throw new BadRequestException('Comment must be provided');
        }

        $includeSpam = in_array('spam', $services);
        $includeRelevance = in_array('relevance', $services);
        $includeCommentScore = in_array('commentscore', $services);
        $includeDogwhistle = in_array('dogwhistle', $services);

        if (($includeRelevance || $includeCommentScore || $includeDogwhistle) && empty($articleContextId)) {
            throw new BadRequestException('Article context ID must be provided for relevance, comment score, or dogwhistle checks');
        }

        $data = [
            'comment' => $comment,
            'run_spam_check' => $includeSpam,
            'run_relevance_check' => $includeRelevance,
            'run_comment_score' => $includeCommentScore,
            'run_dogwhistle_check' => $includeDogwhistle
        ];

        if ($articleContextId !== null) {
            $data['article_context_id'] = $articleContextId;
        }

        if ($includeRelevance && $bannedTopics !== null && !empty($bannedTopics)) {
            $data['banned_topics'] = $bannedTopics;
        }

        if ($includeCommentScore && $replyToComment !== null) {
            $data['reply_to_comment'] = $replyToComment;
        }

        if ($includeDogwhistle && $sensitiveTopics !== null && !empty($sensitiveTopics)) {
            $data['sensitive_topics'] = $sensitiveTopics;
        }

        if ($includeDogwhistle && $dogwhistleExamples !== null && !empty($dogwhistleExamples)) {
            $data['dogwhistle_examples'] = $dogwhistleExamples;
        }

        return $this->client->post(
            $this->getApiUrl('megacall'),
            $this->getHeaders(),
            json_encode($data)
        )->then(function (ResponseInterface $response) {
            if ($response->getStatusCode() === 200) {
                try {
                    $responseData = json_decode((string)$response->getBody(), true);
                    
                    if ($responseData === null) {
                        throw new JsonDecodingException('Failed to decode JSON response');
                    }
                    
                    $responseData = $this->sanitiseReturnedData($responseData);
                    
                    return new MegaCallResult($responseData);
                } catch (\Exception $e) {
                    throw new JsonDecodingException('Error decoding JSON response: ' . htmlspecialchars($e->getMessage(), ENT_QUOTES, 'UTF-8') . ' from response: ' . htmlspecialchars($response->getBody(), ENT_QUOTES, 'UTF-8'));
                }
            } else {
                $this->handleError($response);
            }
        })->otherwise(function (\Exception $e) {
            if ($e instanceof \React\Http\Message\ResponseException) {
                $response = $e->getResponse();
                $this->handleError($response);
            } else {
                throw $e;
            }
        });
    }

    /**
     * Run the [ReactPHP event loop](https://reactphp.org/event-loop/). This allows other tasks to run while waiting for Respectify API responses. 
     * This **must** be called so that the promises resolve.
     */
    public function run(): void {
        $this->loop->run();
    }
}
